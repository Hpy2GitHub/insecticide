console.log("Insecticide content script loaded");

let insecticideActive = false;
let hoverInfoDiv = null;
let currentHoverElement = null;
let ctrlPressed = false;
let observer = null;

// COMPLETE element type to color mapping (all HTML5 elements + more)
const elementColors = {
  // Structural
  'div': 'red',
  'span': 'blue',
  'p': 'green',
  'a': 'orange',
  'ul': 'purple',
  'ol': 'purple',
  'li': 'brown',
  
  // Headings
  'h1': 'darkred',
  'h2': 'darkgreen',
  'h3': 'darkblue',
  'h4': 'darkorange',
  'h5': 'darkviolet',
  'h6': 'darkcyan',
  
  // Semantic
  'section': 'crimson',
  'article': 'chocolate',
  'nav': 'darkmagenta',
  'header': 'darkslateblue',
  'footer': 'darkslategray',
  'main': 'darkgoldenrod',
  'aside': 'darkkhaki',
  'figure': 'darkolivegreen',
  'figcaption': 'darksalmon',
  'details': 'darkseagreen',
  'summary': 'darkslategrey',
  'mark': 'yellow',
  'time': 'lightgray',
  'progress': 'mediumseagreen',
  'meter': 'mediumaquamarine',
  
  // Tables
  'table': 'indigo',
  'thead': 'indigo',
  'tbody': 'indigo',
  'tfoot': 'indigo',
  'tr': 'mediumvioletred',
  'td': 'midnightblue',
  'th': 'navy',
  'caption': 'mediumpurple',
  'colgroup': 'mediumslateblue',
  'col': 'mediumorchid',
  
  // Forms
  'form': 'sienna',
  'input': 'teal',
  'button': 'maroon',
  'textarea': 'steelblue',
  'select': 'rosybrown',
  'option': 'rosybrown',
  'optgroup': 'saddlebrown',
  'label': 'peru',
  'fieldset': 'sandybrown',
  'legend': 'sienna',
  'datalist': 'slategrey',
  'output': 'tan',
  
  // Media
  'img': 'cadetblue',
  'video': 'slateblue',
  'audio': 'dimgray',
  'source': 'gray',
  'track': 'darkgray',
  'canvas': 'orangered',
  'svg': 'mediumvioletred',
  'path': 'mediumorchid',
  'circle': 'mediumpurple',
  'rect': 'mediumslateblue',
  'polygon': 'mediumorchid',
  
  // Text formatting
  'strong': 'darkred',
  'em': 'darkgreen',
  'i': 'darkblue',
  'b': 'darkorange',
  'u': 'darkviolet',
  's': 'darkcyan',
  'sup': 'darksalmon',
  'sub': 'darkseagreen',
  'small': 'lightslategray',
  'code': 'lightslategray',
  'pre': 'dimgray',
  'blockquote': 'silver',
  'q': 'lightsteelblue',
  'cite': 'lightgray',
  'abbr': 'lightcyan',
  'address': 'lightyellow',
  
  // Lists
  'dl': 'purple',
  'dt': 'mediumvioletred',
  'dd': 'midnightblue',
  
  // Interactive
  'menu': 'darkmagenta',
  'menuitem': 'darkorchid',
  'dialog': 'darkgoldenrod',
  
  // Embedding
  'iframe': 'black',
  'embed': 'darkslateblue',
  'object': 'darkslategray',
  'param': 'dimgray',
  
  // Ruby annotations
  'ruby': 'firebrick',
  'rt': 'firebrick',
  'rp': 'firebrick',
  
  // Other
  'wbr': 'transparent',
  'br': 'transparent',
  'hr': 'gray',
  'area': 'lightblue',
  'map': 'lightcoral',
  'picture': 'lightcyan',
  'template': 'lightgray',
  'slot': 'lightpink',
  'shadow': 'lightskyblue',
  
  // Web components / custom elements
  '*': 'hotpink' // For custom elements
};

const defaultColor = 'gray';

// Message listener
browser.runtime.onMessage.addListener((message) => {
  console.log("Content script received message:", message);
  
  if (message.action === 'toggleInsecticide') {
    if (message.isActive) {
      activateInsecticide();
    } else {
      deactivateInsecticide();
    }
    return Promise.resolve({success: true});
  }
});

// Create a unique class name for insecticide borders
const insecticideClass = 'insecticide-border-' + Math.random().toString(36).substr(2, 9);

// Add CSS styles to the page
function addInsecticideStyles() {
  console.log("addInsecticideStyles() called");
  const styleId = 'insecticide-styles';
  
  // Remove existing styles if any
  const existingStyle = document.getElementById(styleId);
  if (existingStyle) {
    existingStyle.remove();
  }
  
  // Create style element
  const style = document.createElement('style');
  style.id = styleId;
  style.textContent = `
    .${insecticideClass} {
      box-sizing: border-box !important;
      position: relative !important;
      background-clip: padding-box !important;
    }
    
    /* Force borders to stay visible */
    .${insecticideClass}::before {
      content: '' !important;
      position: absolute !important;
      top: 0 !important;
      left: 0 !important;
      right: 0 !important;
      bottom: 0 !important;
      pointer-events: none !important;
      z-index: 2147483646 !important;
    }
    
    /* Ensure borders are visible during scrolling */
    .${insecticideClass}, .${insecticideClass} * {
      will-change: transform !important;
      backface-visibility: visible !important;
    }
    
    /* Make sure borders don't affect layout */
    .${insecticideClass} {
      contain: layout style paint !important;
    }
  `;
  
  document.head.appendChild(style);
}

// Add border to a single element
function addBorderToElement(element) {
  console.log("addBordertoElement(e) called");
  if (!element || element === document.documentElement || element === document.body) {
    return;
  }
  
  // Skip elements that already have our border
  if (element.classList.contains(insecticideClass)) {
    return;
  }
  
  const tagName = element.tagName.toLowerCase();
  const color = elementColors[tagName] || 
                elementColors['*'] || 
                defaultColor;
  
  // Skip transparent elements (like br, wbr)
  if (color === 'transparent') {
    return;
  }
  
  // Add our class
  element.classList.add(insecticideClass);
  
  // Store original border
  if (!element.dataset.originalBorder) {
    element.dataset.originalBorder = element.style.border || '';
    element.dataset.originalBoxSizing = element.style.boxSizing || '';
  }
  
  // Apply border
  element.style.border = `1px solid ${color} !important`;
  element.style.boxSizing = 'border-box !important';
  
  // Use CSS custom property for the color
  element.style.setProperty('--insecticide-color', color, 'important');
  
  // Add a pseudo-element for the border to make it more persistent
  element.style.setProperty('border-color', color, 'important');
}

// Remove border from a single element
function removeBorderFromElement(element) {
  console.log("removeBorderFromElement(e) called");
  if (!element || !element.classList.contains(insecticideClass)) {
    return;
  }
  
  element.classList.remove(insecticideClass);
  
  // Restore original border
  if (element.dataset.originalBorder !== undefined) {
    element.style.border = element.dataset.originalBorder;
    delete element.dataset.originalBorder;
  }
  
  if (element.dataset.originalBoxSizing !== undefined) {
    element.style.boxSizing = element.dataset.originalBoxSizing;
    delete element.dataset.originalBoxSizing;
  }
  
  // Remove custom property
  element.style.removeProperty('--insecticide-color');
  element.style.removeProperty('border-color');
}

// Add borders to ALL elements
function addBorders() {
  console.log("Adding borders to all elements");
  
  // Add our CSS styles
  addInsecticideStyles();
  
  // Get ALL elements
  const allElements = document.querySelectorAll('*');
  console.log(`Found ${allElements.length} total elements`);
  
  // Add borders in batches to avoid blocking
  const batchSize = 1000;
  let processed = 0;
  
  function processBatch(start) {
    const end = Math.min(start + batchSize, allElements.length);
    
    for (let i = start; i < end; i++) {
      addBorderToElement(allElements[i]);
    }
    
    processed = end;
    
    if (processed < allElements.length) {
      // Process next batch on next animation frame
      requestAnimationFrame(() => processBatch(processed));
    } else {
      console.log("Finished adding borders to all elements");
      startObserving();
    }
  }
  
  processBatch(0);
}

// Remove borders from ALL elements
function removeBorders() {
  console.log("Removing borders from all elements");
  
  // Stop observing
  if (observer) {
    observer.disconnect();
    observer = null;
  }
  
  // Remove all borders
  const elementsWithBorders = document.querySelectorAll(`.${insecticideClass}`);
  console.log(`Removing borders from ${elementsWithBorders.length} elements`);
  
  elementsWithBorders.forEach(element => {
    removeBorderFromElement(element);
  });
  
  // Remove our styles
  const styleElement = document.getElementById('insecticide-styles');
  if (styleElement) {
    styleElement.remove();
  }
  
  // Hide hover info if visible
  if (hoverInfoDiv) {
    hoverInfoDiv.style.display = 'none';
  }
}

// Observe DOM changes to add borders to new elements
function startObserving() {
  console.log("startObserving");
  if (observer) {
    observer.disconnect();
  }
  
  observer = new MutationObserver((mutations) => {
    if (!insecticideActive) return;
    
    for (const mutation of mutations) {
      // Handle added nodes
      if (mutation.addedNodes.length > 0) {
        mutation.addedNodes.forEach(node => {
          if (node.nodeType === Node.ELEMENT_NODE) {
            // Add border to this element
            addBorderToElement(node);
            
            // Also add borders to all children
            const childElements = node.querySelectorAll('*');
            childElements.forEach(child => addBorderToElement(child));
          }
        });
      }
    }
  });
  
  // Start observing the entire document
  observer.observe(document.documentElement, {
    childList: true,
    subtree: true
  });
  
  console.log("Started observing DOM changes");
}

// OPTIMIZED: Handle scroll events - only update visible elements
function setupScrollHandler() {
  console.log("setupScrollHandler");
  let scrollTimeout = null;
  let isScrolling = false;
  
  const handleScroll = () => {
    if (!insecticideActive) return;
    
    // Mark that we're scrolling
    isScrolling = true;
    
    // Clear existing timeout
    if (scrollTimeout) {
      clearTimeout(scrollTimeout);
    }
    
    // Set a timeout to update visible borders after scrolling stops
    scrollTimeout = setTimeout(() => {
      isScrolling = false;
      
      if (insecticideActive) {
        // Only update elements in viewport (optimized)
        updateVisibleBorders();
      }
    }, 150); // Increased delay for better performance
  };
  
  // OPTIMIZED: Only update borders for elements currently visible in viewport
  function updateVisibleBorders() {
    const viewportHeight = window.innerHeight;
    const viewportWidth = window.innerWidth;
    const scrollTop = window.scrollY;
    const scrollLeft = window.scrollX;
    
    // Get elements with our border class
    const borderedElements = document.querySelectorAll(`.${insecticideClass}`);
    
    // Only process elements that might be visible
    borderedElements.forEach(element => {
      const rect = element.getBoundingClientRect();
      
      // Check if element is in or near viewport (with buffer for smooth scrolling)
      const buffer = 100; // pixels
      const isInViewport = (
        rect.bottom >= -buffer &&
        rect.top <= viewportHeight + buffer &&
        rect.right >= -buffer &&
        rect.left <= viewportWidth + buffer
      );
      
      if (isInViewport) {
        // Reapply border to ensure it's visible
        const tagName = element.tagName.toLowerCase();
        const color = elementColors[tagName] || 
                     elementColors['*'] || 
                     defaultColor;
        
        if (color !== 'transparent') {
          //element.style.border = `1px solid ${color} !important`;
	  element.style.outline = `1px solid ${color} !important`;
          element.style.outlineOffset = `-1px !important`;  // Makes it draw inside, like a border
        }
      }
    });
  }
  
  // Use passive listeners for better scroll performance
  window.addEventListener('scroll', handleScroll, { passive: true });
  window.addEventListener('resize', handleScroll, { passive: true });
  window.addEventListener('orientationchange', handleScroll);
}

// Create hover info div - with body existence check
function createHoverInfoDiv() {
  // Wait for body to exist
  if (!document.body) {
    setTimeout(createHoverInfoDiv, 100);
    return;
  }
  
  if (hoverInfoDiv) {
    hoverInfoDiv.remove();
  }
  
  hoverInfoDiv = document.createElement('div');
  hoverInfoDiv.id = 'insecticide-hover-info';
  hoverInfoDiv.style.cssText = `
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: rgba(0, 0, 0, 0.9);
    color: white;
    padding: 12px 15px;
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    font-size: 11px;
    z-index: 2147483647;
    display: none;
    border-top: 2px solid #4CAF50;
    max-height: 150px;
    overflow-y: auto;
    line-height: 1.4;
  `;
  document.body.appendChild(hoverInfoDiv);
}

function updateHoverInfo(element) {
  if (!hoverInfoDiv || !element) return;
  
  // Clear the div safely
  hoverInfoDiv.textContent = '';
  
  const tagName = element.tagName.toLowerCase();
  const id = element.id ? `#${element.id}` : '';
  
  // Create safe elements instead of a string 
  const infoLine = document.createElement('div');
  infoLine.textContent = `Element: <${tagName}${id}> | ${element.offsetWidth}px x ${element.offsetHeight}px`;
  
  hoverInfoDiv.appendChild(infoLine);
  hoverInfoDiv.style.display = 'block';
}


// Event handlers for hover info
function setupHoverHandlers() {
  function handleMouseOver(e) {
    if (!insecticideActive || !ctrlPressed) return;
    
    currentHoverElement = e.target;
    updateHoverInfo(currentHoverElement);
  }
  
  function handleMouseOut(e) {
    if (!insecticideActive || !hoverInfoDiv) return;
    
    if (currentHoverElement === e.target) {
      hoverInfoDiv.style.display = 'none';
      currentHoverElement = null;
    }
  }
  
  function handleKeyDown(e) {
    if (e.key === 'Control' || e.key === 'Meta') {
      ctrlPressed = true;
      if (insecticideActive && currentHoverElement) {
        updateHoverInfo(currentHoverElement);
      }
    }
  }
  
  function handleKeyUp(e) {
    if (e.key === 'Control' || e.key === 'Meta') {
      ctrlPressed = false;
      if (hoverInfoDiv) {
        hoverInfoDiv.style.display = 'none';
      }
    }
  }
  
  document.addEventListener('mouseover', handleMouseOver, true);
  document.addEventListener('mouseout', handleMouseOut, true);
  document.addEventListener('keydown', handleKeyDown, true);
  document.addEventListener('keyup', handleKeyUp, true);
}

// Activate insecticide - with body existence check
function activateInsecticide() {
  if (insecticideActive) return;
  
  console.log("Activating insecticide");
  insecticideActive = true;
  
  // Create hover info div (with body check inside)
  createHoverInfoDiv();
  
  // Add borders to all elements
  addBorders();
  
  // Setup scroll handler to maintain borders
  setupScrollHandler();
  
  // Setup hover handlers
  setupHoverHandlers();
  
  // Add visual indicator - with body check
  function addIndicator() {
    if (!document.body) {
      setTimeout(addIndicator, 100);
      return;
    }
    
    const indicator = document.createElement('div');
    indicator.id = 'insecticide-active-indicator';
    indicator.textContent = 'INSECTICIDE ACTIVE (Ctrl + Hover for info)';
    indicator.style.cssText = `
      position: fixed;
      top: 10px;
      right: 10px;
      background: #4CAF50;
      color: white;
      padding: 8px 12px;
      z-index: 2147483646;
      font-family: Arial, sans-serif;
      font-size: 12px;
      border-radius: 4px;
      font-weight: bold;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
      pointer-events: none;
    `;
    document.body.appendChild(indicator);
  }
  
  addIndicator();
}

// Deactivate insecticide
function deactivateInsecticide() {
  if (!insecticideActive) return;
  
  console.log("Deactivating insecticide");
  insecticideActive = false;
  
  // Remove borders
  removeBorders();
  
  // Remove hover info
  if (hoverInfoDiv) {
    hoverInfoDiv.remove();
    hoverInfoDiv = null;
  }
  
  // Remove indicator
  const indicator = document.getElementById('insecticide-active-indicator');
  if (indicator) {
    indicator.remove();
  }
  
  currentHoverElement = null;
  ctrlPressed = false;
}

// Add this inside content.js
const handleInitialScroll = () => {
  if (insecticideActive) {
    // Notify background script to deactivate
    browser.runtime.sendMessage({ action: 'deactivateOnScroll' });

    // Optional: Stop listening after the first scroll to save resources
    window.removeEventListener('scroll', handleInitialScroll);
  }
};

// Use a passive listener for better performance
window.addEventListener('scroll', handleInitialScroll, { passive: true });

// Send ready message
console.log("Insecticide content script ready");

