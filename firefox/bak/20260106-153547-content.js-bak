// At the top of content.js
if (window.insecticideLoaded) {
  console.log("Insecticide: Already loaded on this page. Skipping second instance.");
} else {
  window.insecticideLoaded = true;
console.log("Insecticide content script loaded");

const MAX_BORDERED_ELEMENTS = 500;
let borderedElementCount = 0;

let insecticideActive = false;
let hoverInfoDiv = null;
let currentHoverElement = null;
let ctrlPressed = false;
let observer = null;

// COMPLETE element type to color mapping (all HTML5 elements + more)
const elementColors = {
  // Structural
  'div': 'red',
  'span': 'blue',
  'p': 'green',
  'a': 'orange',
  'ul': 'purple',
  'ol': 'purple',
  'li': 'brown',
  
  // Headings
  'h1': 'darkred',
  'h2': 'darkgreen',
  'h3': 'darkblue',
  'h4': 'darkorange',
  'h5': 'darkviolet',
  'h6': 'darkcyan',
  
  // Semantic
  'section': 'crimson',
  'article': 'chocolate',
  'nav': 'darkmagenta',
  'header': 'darkslateblue',
  'footer': 'darkslategray',
  'main': 'darkgoldenrod',
  'aside': 'darkkhaki',
  'figure': 'darkolivegreen',
  'figcaption': 'darksalmon',
  'details': 'darkseagreen',
  'summary': 'darkslategrey',
  'mark': 'yellow',
  'time': 'lightgray',
  'progress': 'mediumseagreen',
  'meter': 'mediumaquamarine',
  
  // Tables
  'table': 'indigo',
  'thead': 'indigo',
  'tbody': 'indigo',
  'tfoot': 'indigo',
  'tr': 'mediumvioletred',
  'td': 'midnightblue',
  'th': 'navy',
  'caption': 'mediumpurple',
  'colgroup': 'mediumslateblue',
  'col': 'mediumorchid',
  
  // Forms
  'form': 'sienna',
  'input': 'teal',
  'button': 'maroon',
  'textarea': 'steelblue',
  'select': 'rosybrown',
  'option': 'rosybrown',
  'optgroup': 'saddlebrown',
  'label': 'peru',
  'fieldset': 'sandybrown',
  'legend': 'sienna',
  'datalist': 'slategrey',
  'output': 'tan',
  
  // Media
  'img': 'cadetblue',
  'video': 'slateblue',
  'audio': 'dimgray',
  'source': 'gray',
  'track': 'darkgray',
  'canvas': 'orangered',
  'svg': 'mediumvioletred',
  'path': 'mediumorchid',
  'circle': 'mediumpurple',
  'rect': 'mediumslateblue',
  'polygon': 'mediumorchid',
  
  // Text formatting
  'strong': 'darkred',
  'em': 'darkgreen',
  'i': 'darkblue',
  'b': 'darkorange',
  'u': 'darkviolet',
  's': 'darkcyan',
  'sup': 'darksalmon',
  'sub': 'darkseagreen',
  'small': 'lightslategray',
  'code': 'lightslategray',
  'pre': 'dimgray',
  'blockquote': 'silver',
  'q': 'lightsteelblue',
  'cite': 'lightgray',
  'abbr': 'lightcyan',
  'address': 'lightyellow',
  
  // Lists
  'dl': 'purple',
  'dt': 'mediumvioletred',
  'dd': 'midnightblue',
  
  // Interactive
  'menu': 'darkmagenta',
  'menuitem': 'darkorchid',
  'dialog': 'darkgoldenrod',
  
  // Embedding
  'iframe': 'black',
  'embed': 'darkslateblue',
  'object': 'darkslategray',
  'param': 'dimgray',
  
  // Ruby annotations
  'ruby': 'firebrick',
  'rt': 'firebrick',
  'rp': 'firebrick',
  
  // Other
  'wbr': 'transparent',
  'br': 'transparent',
  'hr': 'gray',
  'area': 'lightblue',
  'map': 'lightcoral',
  'picture': 'lightcyan',
  'template': 'lightgray',
  'slot': 'lightpink',
  'shadow': 'lightskyblue',
  
  // Web components / custom elements
  '*': 'hotpink' // For custom elements
};

const defaultColor = 'gray';

// Message listener
browser.runtime.onMessage.addListener((message) => {
  console.log("Content script received message:", message);
  
  if (message.action === 'toggleInsecticide') {
    if (message.isActive) {
      activateInsecticide();
    } else {
      deactivateInsecticide();
    }
    return Promise.resolve({success: true});
  }
});

// Create a unique class name for insecticide borders
const insecticideClass = 'insecticide-border-' + Math.random().toString(36).substr(2, 9);

// Add CSS styles to the page
function addInsecticideStyles() {
  console.log("addInsecticideStyles() called");
  const styleId = 'insecticide-styles';
  
  // Remove existing styles if any
  const existingStyle = document.getElementById(styleId);
  if (existingStyle) {
    existingStyle.remove();
  }
  
  // Create style element
  const style = document.createElement('style');
  style.id = styleId;
  style.textContent = `
    .${insecticideClass} {
      box-sizing: border-box !important;
      position: relative !important;
      background-clip: padding-box !important;
    }
    
    /* Force borders to stay visible */
    .${insecticideClass}::before {
      content: '' !important;
      position: absolute !important;
      top: 0 !important;
      left: 0 !important;
      right: 0 !important;
      bottom: 0 !important;
      pointer-events: none !important;
      z-index: 2147483646 !important;
    }
    
    /* Ensure borders are visible during scrolling */
    .${insecticideClass}, .${insecticideClass} * {
      will-change: transform !important;
      backface-visibility: visible !important;
    }
    
    /* Make sure borders don't affect layout */
    .${insecticideClass} {
      contain: layout style paint !important;
    }
  `;
  
  document.head.appendChild(style);
}

function addBorderToElement(element) {
  console.log("addBordertoElement(e) called");
  if (!element || element === document.documentElement || element === document.body) {
    return;
  }

  // Skip elements that already have our border
  if (element.classList.contains(insecticideClass)) {
    return;
  }

  // CHECK LIMIT
  if (borderedElementCount >= MAX_BORDERED_ELEMENTS) {
    if (borderedElementCount === MAX_BORDERED_ELEMENTS) {
      alert(`Insecticide: Maximum element limit (${MAX_BORDERED_ELEMENTS}) reached. Some elements may not have borders.`);
      console.log(`Insecticide: Maximum element limit (${MAX_BORDERED_ELEMENTS}) reached. Some elements may not have borders.`);
      borderedElementCount++; // Increment to prevent multiple alerts
    }
    return;
  }

  const tagName = element.tagName.toLowerCase();
  const color = elementColors[tagName] ||
                elementColors['*'] ||
                defaultColor;

  // Skip transparent elements (like br, wbr)
  if (color === 'transparent') {
    return;
  }

  // Add our class
  element.classList.add(insecticideClass);
  borderedElementCount++;

  // Store original border
  if (!element.dataset.originalBorder) {
    element.dataset.originalBorder = element.style.border || '';
    element.dataset.originalBoxSizing = element.style.boxSizing || '';
  }

  // Apply border
  element.style.border = `1px solid ${color} !important`;
  element.style.boxSizing = 'border-box !important';

  // Use CSS custom property for the color
  element.style.setProperty('--insecticide-color', color, 'important');

  // Add a pseudo-element for the border to make it more persistent
  element.style.setProperty('border-color', color, 'important');
}



function removeBorderFromElement(element) {
  console.log("removeBorderFromElement(e) called");

  // Reset counter
  borderedElementCount = 0;

  if (!element || !element.classList.contains(insecticideClass)) {
    return;
  }
  
  element.classList.remove(insecticideClass);
  borderedElementCount = Math.max(0, borderedElementCount - 1);
  // Restore original border
  if (element.dataset.originalBorder !== undefined) {
    element.style.border = element.dataset.originalBorder;
    delete element.dataset.originalBorder;
  }
  
  if (element.dataset.originalBoxSizing !== undefined) {
    element.style.boxSizing = element.dataset.originalBoxSizing;
    delete element.dataset.originalBoxSizing;
  }
  
  // Remove custom property
  element.style.removeProperty('--insecticide-color');
  element.style.removeProperty('border-color');
}

// Add borders to ALL elements
function addBorders() {
  console.log("Adding borders to all elements");
  
  // Add our CSS styles
  addInsecticideStyles();
  
  // Get ALL elements
  const allElements = document.querySelectorAll('*');
  console.log(`Found ${allElements.length} total elements`);
  
  // Add borders in batches to avoid blocking
  const batchSize = 1000;
  let processed = 0;
  
  function processBatch(start) {
    const end = Math.min(start + batchSize, allElements.length);
    
    for (let i = start; i < end; i++) {
      addBorderToElement(allElements[i]);
    }
    
    processed = end;
    
    if (processed < allElements.length) {
      // Process next batch on next animation frame
      requestAnimationFrame(() => processBatch(processed));
    } else {
      console.log("Finished adding borders to all elements");
      startObserving();
    }
  }
  
  processBatch(0);
}

// Remove borders from ALL elements
function removeBorders() {
  console.log("Removing borders from all elements");
  
  // Stop observing
  if (observer) {
    observer.disconnect();
    observer = null;
  }
  
  // Remove all borders
  const elementsWithBorders = document.querySelectorAll(`.${insecticideClass}`);
  console.log(`Removing borders from ${elementsWithBorders.length} elements`);
  
  elementsWithBorders.forEach(element => {
    removeBorderFromElement(element);
  });
  
  // Remove our styles
  const styleElement = document.getElementById('insecticide-styles');
  if (styleElement) {
    styleElement.remove();
  }
  
  // Hide hover info if visible
  if (hoverInfoDiv) {
    hoverInfoDiv.style.display = 'none';
  }
}

function startObserving() {
  console.log("startObserving");
  if (observer) {
    observer.disconnect();
  }

  observer = new MutationObserver((mutations) => {
    if (!insecticideActive) return;

    // Temporarily disconnect to prevent infinite loop
    observer.disconnect();

    for (const mutation of mutations) {
      // Handle added nodes
      if (mutation.addedNodes.length > 0) {
        mutation.addedNodes.forEach(node => {
          if (node.nodeType === Node.ELEMENT_NODE) {
            // Skip our own hover info div
            if (node.id === 'insecticide-hover-info' ||
                node.id === 'insecticide-active-indicator' ||
                node.id === 'insecticide-styles') {
              return;
            }

            // Add border to this element
            addBorderToElement(node);

            // Also add borders to all children (up to limit)
            if (borderedElementCount < MAX_BORDERED_ELEMENTS) {
              const childElements = node.querySelectorAll('*');
              childElements.forEach(child => addBorderToElement(child));
            }
          }
        });
      }
    }

    // Reconnect observer after processing
    if (insecticideActive) {
      observer.observe(document.documentElement, {
        childList: true,
        subtree: true
      });
    }
  });

  // Start observing the entire document
  observer.observe(document.documentElement, {
    childList: true,
    subtree: true
  });

  console.log("Started observing DOM changes");
}


// IMPROVED: Dynamic border management based on viewport visibility
function setupScrollHandler() {
  console.log("setupScrollHandler - dynamic visibility mode");
  let scrollTimeout = null;

  const handleScroll = () => {
    if (!insecticideActive) return;

    // Clear existing timeout
    if (scrollTimeout) {
      clearTimeout(scrollTimeout);
    }

    // Update borders after scrolling settles
    scrollTimeout = setTimeout(() => {
      if (insecticideActive) {
        updateBordersForVisibility();
      }
    }, 100); // Quick response time
  };

  // Add/remove borders based on element visibility in viewport
  function updateBordersForVisibility() {
    const viewportHeight = window.innerHeight;
    const viewportWidth = window.innerWidth;

    // Buffer zone: start adding/removing borders slightly before elements enter/exit
    const buffer = 200; // pixels outside viewport to preload

    // Get ALL elements in the page
    const allElements = document.querySelectorAll('*');

    allElements.forEach(element => {
      // Skip document root and body
      if (element === document.documentElement || element === document.body) {
        return;
      }

      const rect = element.getBoundingClientRect();

      // Check if element is in or near viewport
      const isInViewport = (
        rect.bottom >= -buffer &&
        rect.top <= viewportHeight + buffer &&
        rect.right >= -buffer &&
        rect.left <= viewportWidth + buffer
      );

      const hasBorder = element.classList.contains(insecticideClass);

      if (isInViewport && !hasBorder) {
        // Element entered viewport - add border
        addBorderToElement(element);
      } else if (!isInViewport && hasBorder) {
        // Element left viewport - remove border to save resources
        removeBorderFromElement(element);
      }
    });

    console.log(`Border update: ${document.querySelectorAll('.' + insecticideClass).length} elements with borders`);
  }

  // Use passive listeners for better scroll performance
  window.addEventListener('scroll', handleScroll, { passive: true });
  window.addEventListener('resize', handleScroll, { passive: true });
  window.addEventListener('orientationchange', handleScroll);

  // Initial update for visible elements when activated
  updateBordersForVisibility();
}

function createHoverInfoDiv() {
  if (hoverInfoDiv) return;

  hoverInfoDiv = document.createElement('div');
  hoverInfoDiv.id = 'insecticide-hover-info';
  hoverInfoDiv.style.cssText = `
    position: fixed;
    top: 60px;           /* Starts below the 10px green indicator */
    right: 10px;         /* Aligned to the right */
    width: 350px;        /* Fixed width so it doesn't cover the whole screen */
    background: rgba(0, 0, 0, 0.9);
    color: white;
    padding: 12px 15px;
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    font-size: 11px;
    z-index: 2147483647;
    display: none;
    border: 1px solid #4CAF50;
    border-radius: 4px;
    max-height: 200px;
    overflow-y: auto;
    line-height: 1.4;
    pointer-events: none; /* Mouse "passes through" so you can inspect elements behind it */
    box-shadow: 0 4px 12px rgba(0,0,0,0.5);
  `;
  document.body.appendChild(hoverInfoDiv);
}

// Create hover info div - with body existence check
function oldCreateHoverInfoDiv() {
  // Wait for body to exist
  if (!document.body) {
    setTimeout(createHoverInfoDiv, 100);
    return;
  }
  
  if (hoverInfoDiv) {
    hoverInfoDiv.remove();
  }
  
  hoverInfoDiv = document.createElement('div');
  hoverInfoDiv.id = 'insecticide-hover-info';
  hoverInfoDiv.style.cssText = `
    position: fixed;
    bottom: 20px;
    right: 20px;
    width:100%;
    left: auto;
    background: rgba(0, 0, 0, 0.9);
    color: white;
    padding: 12px 15px;
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    font-size: 11px;
    z-index: 2147483647;
    display: none;
    border-top: 2px solid #4CAF50;
    max-height: 150px;
    overflow-y: auto;
    line-height: 1.4;
    pointer-events: none;
  `;
  document.body.appendChild(hoverInfoDiv);
}


function oldUpdateHoverInfo(element) {
  if (!hoverInfoDiv || !element) return;

  const tagName = element.tagName.toLowerCase();
  const id = element.id ? `#${element.id}` : '';
  const dimensions = `${element.offsetWidth}px x ${element.offsetHeight}px`;
  const infoText = `Element: <${tagName}${id}> | ${dimensions}`;

  // 1. Update the existing bottom panel (if you still want it)
  if (hoverInfoDiv) {
    // Use textContent instead of innerHTML to pass security validation
    hoverInfoDiv.textContent = `Element: <${tagName}${id}${classes}> | Dimensions: ${dims}`;
    //hoverInfoDiv.textContent = infoText;
    hoverInfoDiv.style.display = 'block';
  }

  // 2. Update the green active indicator box
  const indicator = document.getElementById('insecticide-active-indicator');
  if (indicator) {
    indicator.textContent = `ACTIVE | ${infoText}`;
    indicator.style.background = '#2E7D32'; // Optional: slightly darker green when hovering
  }
}

function oldUpdateHoverInfo(element) {
  if (!hoverInfoDiv || !element) return;
  
  // Clear the div safely
  hoverInfoDiv.textContent = '';
  
  const tagName = element.tagName.toLowerCase();
  const id = element.id ? `#${element.id}` : '';
  
  // Create safe elements instead of a string 
  const infoLine = document.createElement('div');
  infoLine.textContent = `Element: <${tagName}${id}> | ${element.offsetWidth}px x ${element.offsetHeight}px`;
  
  hoverInfoDiv.appendChild(infoLine);
  hoverInfoDiv.style.display = 'block';
}


// Event handlers for hover info
function setupHoverHandlers() {
  function handleMouseOver(e) {
    if (!insecticideActive || !ctrlPressed) return;
    
    currentHoverElement = e.target;
    updateHoverInfo(currentHoverElement);
  }
  
  function handleMouseOut(e) {
    if (!insecticideActive || !hoverInfoDiv) return;
    
    if (currentHoverElement === e.target) {
      hoverInfoDiv.style.display = 'none';
      currentHoverElement = null;
    }
  }
  
  function handleKeyDown(e) {
    if (e.key === 'Control' || e.key === 'Meta') {
      ctrlPressed = true;
      if (insecticideActive && currentHoverElement) {
        updateHoverInfo(currentHoverElement);
      }
    }
  }
  
  function handleKeyUp(e) {
    if (e.key === 'Control' || e.key === 'Meta') {
      ctrlPressed = false;
      if (hoverInfoDiv) {
        hoverInfoDiv.style.display = 'none';
      }
    }
  }
  
  document.addEventListener('mouseover', handleMouseOver, true);
  document.addEventListener('mouseout', handleMouseOut, true);
  document.addEventListener('keydown', handleKeyDown, true);
  document.addEventListener('keyup', handleKeyUp, true);
}

// Activate insecticide - with body existence check
function activateInsecticide() {
  if (insecticideActive) return;
  
  console.log("Activating insecticide");
  insecticideActive = true;
  
  // Create hover info div (with body check inside)
  createHoverInfoDiv();
  
  // Add borders to all elements
  addBorders();
  
  // Setup scroll handler to maintain borders
  setupScrollHandler();
  
  // Setup hover handlers
  setupHoverHandlers();
  
  // Add visual indicator - with body check
  function addIndicator() {
    if (!document.body) {
      setTimeout(addIndicator, 100);
      return;
    }
    
    const indicator = document.createElement('div');
    indicator.id = 'insecticide-active-indicator';
    indicator.textContent = 'INSECTICIDE ACTIVE (Ctrl + Hover for info)';
    indicator.style.cssText = `
      position: fixed;
      top: 10px;
      right: 10px;
      background: #4CAF50;
      color: white;
      padding: 8px 12px;
      z-index: 2147483646;
      font-family: Arial, sans-serif;
      font-size: 12px;
      border-radius: 4px;
      font-weight: bold;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
      pointer-events: none;
    `;
    document.body.appendChild(indicator);
  }
  
  addIndicator();
}

// Deactivate insecticide
function deactivateInsecticide() {
  if (!insecticideActive) return;
  
  console.log("Deactivating insecticide");
  insecticideActive = false;
  
  // Remove borders
  removeBorders();
  
  // Remove hover info
  if (hoverInfoDiv) {
    hoverInfoDiv.remove();
    hoverInfoDiv = null;
  }
  
  // Remove indicator
  const indicator = document.getElementById('insecticide-active-indicator');
  if (indicator) {
    indicator.remove();
  }
  
  currentHoverElement = null;
  ctrlPressed = false;
}

// Send ready message
console.log("Insecticide content script ready");

console.log("Insecticide content script initialized");
}
